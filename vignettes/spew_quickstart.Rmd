---
title: 'SPEW: A brief tour'
author: "Department of Statistics, Carnegie Mellon University"
output:
  pdf_document: default
  html_document:
    highlight: textmate
    theme: flatly
---

```{r, include=FALSE}
library(knitr) # We need the knitr package to set chunk options
# Set default knitr options for knitting code into the report:
opts_chunk$set(cache=TRUE, autodep=TRUE, cache.comments=FALSE)
```
<img src = "spew-too.png" style="height:15%;position:absolute;top:0px;right:0px;" />
	

#	Introduction {.tabset}
Welcome to SPEW (Synthetic Population and Ecosystems of the World).  This guide is for use in for basic usage of the `R` package [spew](https://github.com/leerichardson/spew).  This vignette will walk through the set-up of the ficticious human ecosystem of Tartanville, expanding upon the essential input data for SPEW, supplementary environments and individual-level characteristics, and different methods for producing individuals and their ecosystems.

SPEW uses random sampling to sample both locations of residence for the synthetic individuals and individual records from the microdata.  SPEW is modular in that it can use different methods of sampling to emphasize different aspects of the synthetic ecosystem.  A few methods are demonstrated here.  The methods in **bold** are the default options.	

## A true quickstart 	

### Downloading SPEW	
Open up an `R` session and run the following commands.

          
```{r, eval = FALSE}     
library(devtools)
install_github("leerichardson/spew")
```

###	Tartanville:  Spewing our first synthetic ecosystem		
		
```{r}
## libraries
library(ggplot2)
	
## Generating Tartanville
library(maptools)
library(plyr)
devtools::load_all("~/spew")
data(tartanville)
tartanville_syneco <- spewr(tartanville$pop_table, tartanville$shapefile,
                            tartanville$pums_h, tartanville$pums_p)
plot_syneco(tartanville, tartanville_syneco,
            region_name = "Tartanville", pretty = TRUE)
summarize_syneco(tartanville_syneco,
                 vars_df = data.frame(var_name = c("NP", "HHINC", "AGEP", "SEX"),
                                      pop_type = c("hh", "hh", "p", "p"),
                                      var_type = c("cont", "cont", "cont", "cat"),
                                      stringsAsFactors = FALSE), verbose = TRUE)
```

	
	





## Sampling of locations {.tabset}

1. **Uniform sampling**

2. Road-based sampling

### Uniform sampling 
Uniform sampling of locations means sampling uniformly within the boundaries of a region from the inputted shapefile.  Population density is maintained at a macro-level but may not accurately reflect the actual population density of a region.  For instance, synthetic individuals may be placed in lakes by mistake under this method.

**Ex.** As shown in the 'A true quickstart' tab.

### Road-based sampling 
Roads-based sampling requires the shapefile to be a list with two entries, the first as the `boundaries` and the second as the `roads`.  The first entry should be a shapefile of polygons, and the second, a shapefile of lines.  We see that the resulting synthetic ecosystem is much closer to the roads.
**Ex.**
```{r}
 devtools::load_all("~/spew")
data(tartanville)
library(plyr)
shapefile <- list(boundaries = tartanville$shapefile, roads = tartanville$roads)

tartanville_syneco <- spewr(tartanville$pop_table, shapefile,
                            tartanville$pums_h, tartanville$pums_p,
                            locations_method = "roads")
plot_syneco(tartanville, tartanville_syneco,
            region_name = "Tartanville", pretty = TRUE)
```	
     
## Sampling of characteristics {.tabset}

1. **Uniform sampling**

2. Moment Matching (MM)

3.  Iterative Proportional Fitting (IPF)   

### Uniform sampling
     
Uniform sampling of population characteristics means sampling from the microdata where each record is given equal weight.  Thus, is the microdata is thought to be representative of the regions, then the resulting synthetic individuals should have close to the correct distribution of population characteristics.  If the microdata is not representative, then we must implement other sampling methods.

**Ex.** As shown in the 'A true quickstart' tab.



	
### Moment Matching
Say we have the first moment(s) of a continuous or ordered variable(s)'s distribution  for every sub-region in the region of interest (e.g. average household size for every block in Tartanville).  Moment matching is a method to calculate weights for the microdata records so that after sampling, the sample average of the variable(s) will be matched to the given averages.  We demonstrate with the average household size (NP) of Tartanville.  The average household sizes have been exaggerated here as we are generating a small synthetic population.

**Ex.**

We first make the `moments` object for use in SPEW.    Here, the moments object is the average household size for each tract.  The function `make_mm_obj` puts the data necessary for MM in the right format.  The format is discussed more in another section.  The `supplementary_data` is thus a list including the `moments` outputted from `make_mm_obj`.
       
```{r}
NP_avg <- c(3.2, 0, 6.0,
            2.0, 3.2, 3.1,
            4.0, 4.8, 3.9)
supplementary_data <- list(moments = make_mm_obj(moments_list =
                           list(mom1 = data.frame(place_id = paste0("T", 1:9),
                                                  puma_id = "T",
                                                  NP = NP_avg)),
                           assumption = "independence",
                                nMom = 1, type = "cont"))

```
And then we use SPEW, with the additional library `quadprog`, which is required for MM.  Note we have supplemented `spewr` with both a `supplementary_data` argument and the sampling method of `'mm'`.  The outputted synthetic ecosystem is in the same format.  We see that MM matches the inputted average household sizes well.

```{r}
library(quadprog)
tartanville_syneco_mm <- spewr(tartanville$pop_table, tartanville$shapefile,
                               tartanville$pums_h, tartanville$pums_p,
                               supplementary_data = supplementary_data,
                               sampling_method = "mm")

out <- summarize_syneco(tartanville_syneco_mm,
                 vars_df = data.frame(var_name = c("NP"),
                                      pop_type = c("hh"),
                                      var_type = c("cont"),
                                      stringsAsFactors = FALSE), verbose = TRUE)
abs(out$NP$Mean - NP_avg[-2])
```


### Iterative Proportional Fitting

Iterative Proportional Fitting is a method discovered by Deming and Stephan (1941) and implemented as a sampling scheme by Beckman et al. (1996).  The idea behind IPF is filling in a cotingency table where the marginal totals are known.    As such, an important step is "cutting" our variables into discrete categories if they are not already.

In SPEW, we do this by creating a `marginals` object which contains information both how to cut our variables into categories	  and how many of each category we expect in each region for each marginal variable.  We demonstrate this below.

**Ex.** We must make the `marginals` object for use of the IPF sampling method.  We create two marginal objects, one for household income and the other for head of household race and combine them together for use in SPEW.

```{r}
## Income
var_name <- "HHINC"
## How to cut the variable
type <- "ord"
bounds <- data.frame(lower = c(0, 50), upper = c(49, Inf))
category_name <- c("HHINC_0-49", "HHINC_50-Inf")
## How often we expect to see each category for each region.
df <- data.frame(place_id = paste0("T", 1:9),  v1 = c(30, 0, 5, 10, 13, 9, 2, 1, 5))
df$v2 <- tartanville$pop_table$n_house - df$v1
#
ipf_obj_hhinc<- make_ipf_obj(var_name, type, bounds, category_name, df = df)

ipf_obj_hhinc

## Head of Household Race
var_name <- c("RAC1P")
var_name <- "HHINC"
type <- "cat"
bounds <- data.frame(lower = c(1, 2), upper = c(1, 2))
category_name <- c("Tartan", "Argyle")
df2 <- data.frame(place_id = paste0("T", 1:9),  v1 = c(28, 0, 4, 1, 5, 8, 2, 1, 3))
df2$v2 <- tartanville$pop_table$n_house - df2$v1
#
ipf_obj_rac1p <- make_ipf_obj(var_name, type, bounds, category_name, df = df2)


# Combine both together
ipf_obj <- list(HHINC = ipf_obj_hhinc[[1]], RAC1P = ipf_obj_rac1p[[1]])
supplementary_data <- list(moments = ipf_obj)

```
As demonstration of how we cut our variables, we use a function called `align_pums`.  
	
```{r}
pums_h <- align_pums(tartanville$pums_h, ipf_obj, suffix = "_ipf") # split into categories
kable(head(pums_h))
```

We are now ready to perform IPF-sampling and do so below.  We find that IPF matches the table we gave as expected number of households for each category in each marginal variable quite well. **Note:** IPF does not always converge, generally due to having a cell in the contingency with value 0.
```{r}
library(mipfp)
tartanville_syneco_ipf <- spewr(tartanville$pop_table, tartanville$shapefile,
                               pums_h, tartanville$pums_p,
                               supplementary_data = supplementary_data,
                               sampling_method = "ipf")



out <- summarize_syneco(tartanville_syneco_ipf,
                 vars_df = data.frame(var_name = c("HHINC_ipf", "RAC1P_ipf"),
                                      pop_type = c("hh", "hh"),
                                      var_type = c("cat", "cat"),
                                      stringsAsFactors = FALSE), verbose = TRUE)

## to compare
sum(abs(as.matrix(out$HHINC_ipf[, -1]) - as.matrix(df[-2, -1])))
sum(abs(as.matrix(out$RAC1P_ipf[, -1]) - as.matrix(df2[-2, -1])))
```


	

## Assigning environments

### General assignment function
   
We can also assign environments to the population of Tartanville.  Environments are locations where the agents interact, both with one another, and possibly the environment itself.
   
**Ex.**  We assign the children between ages 5 and 18 in T1 to one of the two schools in Tartanville.
```{r}
kable(tartanville$environments)
tartanville_syneco <- tartanville_syneco <- spewr(tartanville$pop_table, tartanville$shapefile,
                                                  tartanville$pums_h, tartanville$pums_p)
plot_syneco(tartanville, tartanville_syneco,
            region_name = "Tartanville", pretty = TRUE)	
```

We first subset the data frame of students in T1.

```{r}
t1_people <- tartanville_syneco[[1]]$people
t1_students <- subset(t1_people, subset = (t1_people$AGEP >= 5 & t1_people$AGEP <= 18))
places <- subset(tartanville$environments, tartanville$environments$Type == "School")
```

We then assign the schools to the children, first without regard to capacity.
```{r}
t1_assignments <- assign_place_coords(t1_students, places = places, place_name = "school")
table(t1_assignments$school)
```	

These values are consistent as Andrew High (T7) is slightly closer to T1 than Maggie Mo High (T9), but only by a small distance.

However, we note that Maggie Mo High has about 4 times the capacity than Andrew High.  If we take capacity into account, then we have more students going to Maggie Mo High.  The user is encouraged to provide their own distance and capacity functions.  The details may be found in the documentation of  `assign_place__cords`.
	 

```{r}
t1_assignments <- assign_place_coords(t1_students, places = places, place_name = "school", method = "capacity")
table(t1_assignments$school)
```		 
	
	
## Essential input data to SPEW format

SPEW requires three essential data inputs connected through the variables `place_id` and `puma_id`.

| Input Data        | Description                                                    | Required Variables    | Format |
|-------------------|----------------------------------------------------------------|-----------------------|--------|
| Population Counts | Table of number of individuals per region                      | `place_id`, `puma_id` | `.csv` |
| Shapefile         | Spatial boundaries of the regions in Population Counts         | `place_id`            | `.shp` |
| Microdata         | Table of individual records with individual-level characteristics | `puma_id`             | `.csv` |

Given a row in the table of population counts with the variables `place_id` and `puma_id`, one should be able to find the unique region `place_id` in the shapefile that matches that of the row along with the microdata records with the same `puma_id`. 
	
## Supplementary data format


## Advanced SPEW   