#' Append populations within a directory into two separate files:  household and people populations.
#'
#' @param input_dir path to the directory (bottom level) of populations to append
#' @param output_dir path to output directory
#' @param remove_pops TRUE if we should we remove the smaller populations
#' @return TRUE
append_pops <- function(input_dir, output_dir=input_dir, remove_pops=FALSE){
    filenames <- list.files(input_dir)
    filenames_hh <- filenames[ grep("household", filenames) ]
    filenames_p <- filenames[ grep("people", filenames) ]
    #read in the files
    header_hh <- names(read.csv(paste0(input_dir, filenames_hh[1])))
    header_p <- names(read.csv(paste0(input_dir, filenames_p[1])))
    #warning!!! potentially veryyy slow
    # we do not read the header of every file
    hh_list <- lapply(paste0(input_dir, filenames_hh), read.table, sep=",", skip=1)
    p_list <- lapply(paste0(input_dir, filenames_p), read.table, sep=",", skip=1)
    # rowbinding the list to make one large file
    hh_comb <- do.call('rbind', hh_list)
    rm(hh_list)
    p_comb <- do.call('rbind', p_list)
    rm(p_list)
    colnames(hh_comb) <- header_hh
    colnames(p_comb) <- header_p
    puma_id <- hh_comb$puma_id[1]
    new_filename_hh <- paste0("household_", puma_id, ".csv")
    new_filename_p <- paste0("people_", puma_id, ".csv")
    #remove old files if asked
    if(remove_pops){
        file.remove(paste0(input_dir, filenames_hh))
        file.remove(paste0(input_dir, filenames_p))
    }
    #write out the files
    write.csv(hh_comb, paste0(output_dir, new_filename_hh), row.names=FALSE)
    write.csv(p_comb, paste0(output_dir, new_filename_p), row.names=FALSE)
    return(TRUE) 
}

#' Reads in and concatenates a list of filenames and pastes on the header file
#' @param filenames full paths to files to be concatenated
#' @return dataframe of population
read_concat_pop <- function(filenames){
    stopifnot(length(filenames) > 0)
    pop_list <- lapply(filenames, read.table, sep=",", skip=1)
    pop_df <- do.call('rbind', pop_list)
    header <- readLines(filenames[1], n=1)
    header <- unlist(strsplit(header, split=","))
    header <- gsub("[[:punct:]]", "", header)
    #print(header)
    colnames(pop_df) <- header
    return(pop_df)
}








#' Version 2 of run_diags.  This will instead return a row of summary numbers with a corresponding column name.
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param input_dir Path to synthetic population outputs generated by generate_spew.  The basename of this dir will be used as the region name unless otherwise specified.
#' @param output_dir Directory where files should be output.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.  For the summary output to be something other than a factor variable then see var_list.
#' @param region_name string default is basename of input_dir
#' @param var_list category labels.  Each name of a list entry should correspond to a variable in summary_vars.  The actual entry then is the category names.
#' @export
#' @return summary_list list of summary numbers and list of features
summary_diags <- function(type="hh",input_dir="./", output_dir=input_dir, summary_vars="base", region_name=basename(input_dir), var_list=NULL){
    stopifnot(type %in% c("hh", "p"))
    pop_list<- read_pop(type, input_dir, summary_vars)
    summary_list <- summarize_pop(pop_list, region_name)
    return(summary_list)
}


#' Version 3 of run_diags.
#'
#' This will instead return a row of summary numbers with a corresponding column name.
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param input_dir Path to synthetic population outputs generated by generate_spew.  The basename of this will be used as the region name
#' @param output_dir Directory where files should be output.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.  For the summary output to be something other than a factor variable then see var_list.
#' @param region_name string default is basename of input_dir
#' @param var_list category labels.  Each name of a list entry should correspond to a variable in summary_vars.  The actual entry then is the category names.
#' @export
#' @return summary_list list of summary numbers and list of features
summary_diags2 <- function(type="hh",input_dir="./", output_dir=input_dir, summary_vars="base", region_name=basename(input_dir), var_list=NULL){
    stopifnot(type %in% c("hh", "p"))
    if( grepl(".csv", region_name)){
        region_name <- gsub(".*output_|_household.csv|_people.csv", "", region_name)
    }
    pop_list<- read_pop2(type, input_dir, summary_vars)
    summary_list <- summarize_pop(pop_list, region_name)
    return(summary_list)
}





#' Get the summary values of a spew generated synthetic population and output a row of summary and the column names
#' @param pop_list list of  dataframe of the population subsetted to the summary variables and the actual names
#' @param region_name string of region_name
#' @return summary_list list of summary numbers with corresponding names

summarize_pop <- function(pop_list, region_name){
    names <- c(region_name, colnames(pop_list$pop))
    i <- 1
    coords <- NULL
    row_list <- NULL
    nRecords <- nrow(pop_list$pop)
    df <- as.data.frame(pop_list$pop)
    if ("longitude" %in% colnames(df)){
        coords <- colMeans(df[,c("longitude", "latitude")])
        i <- 3
    }
    if ( i <= ncol(df)){
        row_list <- lapply(i:ncol(df), function(i){
            tab <- table(df[,i])
            names(tab) <- paste0(colnames(df)[i],"_", names(tab))
            return(tab)
        })
    }
    summary_row <- data.frame(region_name=region_name, nRecords=nRecords)
    return(list(summary_row=summary_row, features=row_list, all_names=pop_list$all_vars))
}



#' Read in the population and subset it to appropriate variables
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param input_dir Path to synthetic population outputs generated by generate_spew.  The basename of this dir will be used as the region name unless otherwise specified.
#' @param output_dir Directory where files should be output.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.
#' @return pop_list list of  dataframe of the population subsetted to the summary variables and the actual names
read_pop2 <- function(type, input_dir, summary_vars){
    var_names <- get_var_names(type, summary_vars)

    #TODO:  FIX.  Seems to be losing records
    pop <- data.table::fread(input_dir)
    
    stopifnot(var_names %in% colnames(pop))
    all_vars <- colnames(pop)
    pop <- subset(pop, select=var_names)
    return(list(pop=pop, all_vars=all_vars))
}



#' Read in the population and subset it to appropriate variables
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param input_dir Path to synthetic population outputs generated by generate_spew.  The basename of this dir will be used as the region name unless otherwise specified.
#' @param output_dir Directory where files should be output.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.
#' @return pop_list list of  dataframe of the population subsetted to the summary variables and the actual names
read_pop <- function(type, input_dir, summary_vars){
    var_names <- get_var_names(type, summary_vars)
    key_word <- ifelse(type == "hh", "household", "people")
    concat_file <- paste0(input_dir, key_word, "_", basename(input_dir), ".csv")
    print(concat_file)
    #TODO:  FIX.  Seems to be losing records
    if( file.exists(concat_file)){
        pop <- data.table::fread(concat_file)
    } else {
        filenames <- list.files(input_dir)
        filenames <- filenames[ grep(key_word, filenames)]
        full_paths <- paste0(input_dir, filenames)
        pop <- read_concat_pop(full_paths)
    }
    stopifnot(var_names %in% colnames(pop))
    all_vars <- colnames(pop)
    pop <- subset(pop, select=var_names)
    return(list(pop=pop, all_vars=all_vars))
}

#' Get the proper names to subset
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.
#' @return var_names a vector of variable names
get_var_names <- function(type, summary_vars){
    if ( type == "hh"){
        if( summary_vars == "base"){
            var_names <- c("longitude", "latitude")
        } else{
            var_names <- c("longitude", "latitude", summary_vars)
        }
    } else {
        if (summary_vars == "base"){
            var_names <- c("SEX")
        } else {
            var_names <- c("SEX", summary_vars)
        }
    }
    return(var_names)
}



#' Run basic 'sanity check' diagnostics on a folder of SPEW generated populations.  There should only be one household and one people file in each folder.  If not, look into append_pops().
#' 
#' @param input_dir path to the directory (bottom level) of populations to summarize
#' @param output_dir path to output directory
#' @param save_plots boolean indicating whether the plots should be saved
#' @param pretty if set to TRUE, should generate a summary pdf including plots (currently non-functional)
#' @return  a print out of the files generated

run_diags <- function(input_dir="./", output_dir=input_dir, save_plots=TRUE, pretty=FALSE){
    #read in filenames
    filenames <- list.files(input_dir)
    filename_hh <- filenames[ grep("household", filenames) ]
    filename_p <- filenames[ grep("people", filenames) ]
    stopifnot(length(filename_hh) * length(filename_p) == 1)
    hh_df <- data.table::fread(paste0(input_dir, filename_hh))
    # write log file
    
    puma_id <- unique(hh_df$puma_id)
    log_filename <- paste0("log_", puma_id, ".txt")
    if(!prettY){
      sink(paste0(output_dir, log_filename))
    }
    print(paste("PUMA ID:", puma_id))
    print("\n")
    print("HOUSEHOLDS")
    print("\n")
    print(paste("Number of households:", nrow(hh_df)))
    print("\n")
    print("Household column names:")
    print(colnames(hh_df))
    print("\n")
    print(paste("Average Longitude:", round(mean(hh_df$long),3)))
    print(paste("Average Latitude:", round(mean(hh_df$lati),3)))
    print("\n")
    print(paste("Number of unique households sampled:", length(unique(hh_df$SERIALNO))))
    print("\n")
    if(!pretty){
      sink()
    }
    
    rm(hh_df)

    #the people information
    p_df <- data.table::fread(paste0(input_dir, filename_p))
  
    if(!pretty){
      sink(paste0(output_dir, log_filename), append=TRUE)
    }
    print("PEOPLE")
    print("\n")
    print(paste("Number of individuals:", nrow(p_df)))
    print("\n")
    print("Column names:")
    print(colnames(p_df))
    mfr<-sum(p_df$SEX == 1)/sum(p_df$SEX == 2)
    print(paste("Male to Female Ratio:", round(mfr, 2)))
    if(!pretty){
    sink()
    }
    return(row)

}


#' Sumarize the files within the output dir
#'
#' @param output_dir path to output of SPEW region name
#' @param doPrint logical
#' @param type either "ipums" or "us"
#' @return list
summarizeFileStructure <- function(output_dir, doPrint = FALSE, type = "ipums"){
    stopifnot(type %in% c("ipums", "us"))
    # Region Name
    base_region <- gsub("output_", "", basename(output_dir))
    pretty_print(doPrint, paste("The region is", toupper(base_region)))
    stopifnot("eco" %in% list.files(output_dir))
    paths <- list.files(output_dir, recursive = T)
    output_paths <- paths[grepl("output", paths)]
    if (length(output_paths) < 1){
           hh_paths <- paths[grepl("household", paths)]
    } else {
        hh_paths <- output_paths[grepl("household", output_paths)]
    }
    paths_df <- pathsToDF(hh_paths)
    # Number of levels in file hierarchy
    nLevels <- getLevels(paths_df)
    pretty_print(doPrint, paste("There are", nLevels,
                                "level(s) of nested ecosystems in this region."))
    nRegions <- nrow(paths_df)
    pretty_print(doPrint, paste("There are", nRegions, "lowest level subregions in", toupper(base_region)))
    return(list(base_region = base_region, paths_df = paths_df, nLevels = nLevels))
}

#' Convert paths to data frame based on folders
#'
#' @param paths paths separated by a single /
#' @return df of paths
pathsToDF <- function(paths){
    ll <- strsplit(paths, "/")
    nLevels <- max(sapply(ll, length))
    inds <- sapply(ll, function(val) length(val) == nLevels)
    mat <- do.call(rbind, ll[inds])
    df <- as.data.frame(mat)
    colnames(df) <- paste0("folder", 1:ncol(df))
    return(df)
}




#' Print text if doPrint
#'
#' @param doPrint logical
#' @param text string
#' @return print statement
pretty_print <- function(doPrint = TRUE, text){
    if (doPrint){
        print(text)
    }
}


#' Get the number of levels in the structure
#'
#' @param paths_df paths df
#' @return number of levels in file path
getLevels <- function(paths_df){
    if (ncol(paths_df) < 3){
        return(1)
    }else if (ncol(paths_df) == 3){
        un1 <- length(unique(paths_df[, 1]))
        un2 <- length(unique(paths_df[, 3]))
        if (un1 == un2){
            return(1)
        } else {
            return(2)
        }
    } else {
        return( floor(ncol(paths_df) / 2) + 1)
    }
}

#' Summarize ipums populations
#'
#' @param output_dir path
#' @param ipums_fs output from summarizeFileStructure
# #' @param shapefile_path default is NA, uses output_dir
#' @param varsToSummarize list with first entry as vector of household ipums vars and the second as person ipums vars.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.  For the summary output to be something other than a factor variable then see var_list.
#' @param doPrint logical
#' @param sampSize number of people to retain (default is 10000) per region for plotting
summarize_ipums <-  function(output_dir, ipums_fs,
                             varsToSummarize = list(vars_hh = "base", vars_p = "base"),
                             doPrint = FALSE, sampSize = 10^4){
    stopifnot(ncol(ipums_fs$paths_df) == 3)
    paths_df <- ipums_fs$paths_df
    vars_hh <- getVars_ipums(varsToSummarize$vars_hh, type = "hh")
    vars_p <- getVars_ipums(varsToSummarize$vars_p, type = "p")
    hh_sum_list <- vector(mode = "list", length = nrow(paths_df))
    pretty_print(doPrint, "Summarizing households!")
    header <- NULL  ## HOUSEHOLDS!!
    for (ind in 1:nrow(paths_df)){
        fp <- paste(paths_df[ind, ], collapse = "/")
        tab <- as.data.frame(fread(file.path(output_dir, fp)))
        sum_features_cat <- sapply(vars_hh$cat, summarizeFeatures, tab, type = "cat")
        sum_features_cont <- sapply(vars_hh$cont, summarizeFeatures, tab, type = "cont")
        sum_features <- c(sum_features_cat, sum_features_cont)
        header_hh<- colnames(tab)
        sampSize <- ifelse(sampSize > nrow(tab), nrow(tab), sampSize)
        sub_inds <- sample(1:nrow(tab), sampSize, replace = T)
        sub_df <- subset(tab[sub_inds,], select = c("longitude", "latitude"))
        regionID <- gsub("household_", "", basename(fp))
        region_id<- gsub(".csv", "", regionID)
        region_no <- gsub("output_", "", paths_df[ind, 1])
        pretty_print(doPrint, region_id)
        if ("longitude" %in% colnames(tab)){
            coords <- colMeans(tab[, c("longitude", "latitude")])        
        }
        region_sum <- data.frame(region_id = region_id,
                                 region_no = region_no, nRecords = 12,
                                 avg_lon = coords[1], avg_lat = coords[2])
        rownames(region_sum) <- NULL
        hh_sum_list[[ind]] <- list(region_sum = region_sum,
                                   sum_features = sum_features,
                                   sub_df = sub_df, header = header_hh)

    }
    p_sum_list <- vector(mode = "list", length = nrow(paths_df))
    ### PEOPLE!!
    pretty_print(doPrint, "Summarizing people!")
    for (ind in 1:nrow(paths_df)){
        paths_df_p <- paths_df
        paths_df_p[, ncol(paths_df)] <- gsub("household", "people", paths_df[, ncol(paths_df)])
        fp <- paste(paths_df_p[ind, ], collapse = "/")
        tab <- as.data.frame(fread(file.path(output_dir, fp)))
        sum_features_cat <- sapply(vars_p$cat, summarizeFeatures, tab, type = "cat")
        sum_features_cont <- sapply(vars_p$cont, summarizeFeatures, tab, type = "cont")
        sum_features <- c(sum_features_cat, sum_features_cont)
        sampSize <- ifelse(sampSize > nrow(tab), nrow(tab), sampSize)
        sub_inds <- sample(1:nrow(tab), sampSize, replace = T)
        regionID <- gsub("people_", "", basename(fp))
        region_id<- gsub(".csv", "", regionID)
        region_no <- gsub("output_", "", paths_df[ind, 1])
        pretty_print(doPrint, region_id)
        if ("longitude" %in% colnames(tab)){
            coords <- colMeans(tab[, c("longitude", "latitude")])        
        }
        region_sum <- data.frame(region_id = region_id,
                                 region_no = region_no, nRecords = 12)
        rownames(region_sum) <- NULL
        p_sum_list[[ind]] <- list(region_sum = region_sum,
                                   sum_features = sum_features)

    }
    return(list(hh_sum_list = hh_sum_list, header_hh = header_hh, p_sum_list = p_sum_list))
}



getVars_ipums <- function(summary_vars, type){
     if ( type == "hh"){
        if( summary_vars == "base"){
            var_names <- NULL
        } else{
            var_names <- summary_vars
        }
    } else {
        if (summary_vars == "base"){
            var_names <- c("SEX")
        } else {
            var_names <- c("SEX", summary_vars)
        }
    }
    return(list(cat = var_names, cont = NULL))
}


summarizeFeatures <- function(var, tab, type = "cat"){
    if (is.null(var)){
        return(TRUE)
    } else if ( type == "cat"){
        sum_tab <- table(tab[, var])
        names(sum_tab) <- paste0(var, "-", names(sum_tab))
        return(sum_tab)                                 
    } else {
        return(FALSE)
    }
}
