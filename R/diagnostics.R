#' Append populations within a directory into two separate files:  household and people populations.
#'
#' @param input_dir path to the directory (bottom level) of populations to append
#' @param output_dir path to output directory
#' @param remove_pops TRUE if we should we remove the smaller populations
#' @return TRUE
append_pops <- function(input_dir, output_dir=input_dir, remove_pops=FALSE){
    filenames <- list.files(input_dir)
    filenames_hh <- filenames[ grep("household", filenames) ]
    filenames_p <- filenames[ grep("people", filenames) ]
    #read in the files
    header_hh <- names(read.csv(paste0(input_dir, filenames_hh[1])))
    header_p <- names(read.csv(paste0(input_dir, filenames_p[1])))
    #warning!!! potentially veryyy slow
    # we do not read the header of every file
    hh_list <- lapply(paste0(input_dir, filenames_hh), read.table, sep=",", skip=1)
    p_list <- lapply(paste0(input_dir, filenames_p), read.table, sep=",", skip=1)
    # rowbinding the list to make one large file
    hh_comb <- do.call('rbind', hh_list)
    rm(hh_list)
    p_comb <- do.call('rbind', p_list)
    rm(p_list)
    colnames(hh_comb) <- header_hh
    colnames(p_comb) <- header_p
    puma_id <- hh_comb$puma_id[1]
    new_filename_hh <- paste0("household_", puma_id, ".csv")
    new_filename_p <- paste0("people_", puma_id, ".csv")
    #remove old files if asked
    if(remove_pops){
        file.remove(paste0(input_dir, filenames_hh))
        file.remove(paste0(input_dir, filenames_p))
    }
    #write out the files
    write.csv(hh_comb, paste0(output_dir, new_filename_hh), row.names=FALSE)
    write.csv(p_comb, paste0(output_dir, new_filename_p), row.names=FALSE)
    return(TRUE) 
}

#' Reads in and concatenates a list of filenames and pastes on the header file
#' @param filenames full paths to files to be concatenated
#' @return dataframe of population
read_concat_pop <- function(filenames){
    stopifnot(length(filenames) > 0)
    pop_list <- lapply(filenames, read.table, sep=",", skip=1)
    pop_df <- do.call('rbind', pop_list)
    header <- readLines(filenames[1], n=1)
    header <- unlist(strsplit(header, split=","))
    header <- gsub("[[:punct:]]", "", header)
    #print(header)
    colnames(pop_df) <- header
    return(pop_df)
}








#' Version 2 of run_diags.  This will instead return a row of summary numbers with a corresponding column name.
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param input_dir Path to synthetic population outputs generated by generate_spew.  The basename of this dir will be used as the region name unless otherwise specified.
#' @param output_dir Directory where files should be output.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.  For the summary output to be something other than a factor variable then see var_list.
#' @param region_name string default is basename of input_dir
#' @param var_list category labels.  Each name of a list entry should correspond to a variable in summary_vars.  The actual entry then is the category names.
#' @return summary_list list of summary numbers with corresponding names

summary_diags <- function(type="hh",input_dir="./", output_dir=input_dir, summary_vars="base", region_name=basename(input_dir), var_list=NULL){
    stopifnot(type %in% c("hh", "p"))
    #EVENTUALLY remove below check
    stopifnot(summary_vars="base")
    pop_list<- read_pop(type, input_dir, summary_vars)
    summary_row <- summarize_pop(pop_list, region_name)
    return(summary_list)
}

#' Get the summary values of a spew generated synthetic population and output a row of summary and the column names
#' @param pop_list list of  dataframe of the population subsetted to the summary variables and the actual names
#' @param region_name string of region_name
#' @return summary_list list of summary numbers with corresponding names

summarize_pop <- function(pop_list, region_name){
    names <- c(region_name, colnames(pop_list$pop))
    i <- 2
    coords <- NULL
    row_list <- NULL
    nRecords <- nrow(pop_list$pop)
    if ("longitude" %in% colnames(pop_list$pop)){
        coords <- colMeans(pop_list$pop[,c("longitude", "latitude")])
        i <- 4
    }
    if ( i <= ncol(pop_list)){
        row_list <- lapply(i:ncol(pop_list$pop), function(i) table(pop_list$pop[,i]))
    }
    summary_row <- c(region_name, nRecords, coords, row_list)
    summary_names <- names(unlist(row_list))
    return(list(summary_row=summary_row, summary_names=summary_names))

}


#' Read in the population and subset it to appropriate variables
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param input_dir Path to synthetic population outputs generated by generate_spew.  The basename of this dir will be used as the region name unless otherwise specified.
#' @param output_dir Directory where files should be output.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.
#' @return pop_list list of  dataframe of the population subsetted to the summary variables and the actual names
read_pop <- function(type, input_dir, summary_vars){
    var_names <- get_var_names(type, summary_vars)
    key_word <- ifelse(type == "hh", "household", "people")
    concat_file <- paste0(input_dir, key_word, "_", basename(input_dir), ".csv")
    print(concat_file)
    if( file.exists(concat_file)){
        pop <- data.table::fread(concat_file)
    } else {
        filenames <- list.files(input_dir)
        filenames <- filenames[ grep(key_word, filenames)]
        full_paths <- paste0(input_dir, filenames)
        pop <- read_concat_pop(full_paths)
    }
    stopifnot(var_names %in% colnames(pop))
    all_vars <- colnames(pop)
    pop <- subset(pop, select=var_names)
    return(list(pop=pop, all_vars=all_vars))
}

#' Get the proper names to subset
#' @param type string of either "hh" or "p" designating to either summarize household populations or individual populations.
#' @param summary_vars which variables should we summarize.  The default value is 'base' which includes total number of records.  For households 'base' includes longitude and latitude and the names.  For people, this includes gender.  Otherwise we summarize the base variables and the the variable names which we should summarize.
#' @return var_names a vector of variable names
get_var_names <- function(type, summary_vars){
    if ( type == "hh"){
        if( summary_vars == "base"){
            var_names <- c("longitude", "latitude")
        } else{
            var_names <- c("longitude", "latitude", summary_vars)
        }
    } else {
        if (summary_vars == "base"){
            var_names <- c("SEX")
        } else {
            var_names <- c("SEX", summary_vars)
        }
    }
    return(var_names)
}



#' Run basic 'sanity check' diagnostics on a folder of SPEW generated populations.  There should only be one household and one people file in each folder.  If not, look into append_pops().
#' 
#' @param input_dir path to the directory (bottom level) of populations to summarize
#' @param output_dir path to output directory
#' @param save_plots boolean indicating whether the plots should be saved
#' @param pretty if set to TRUE, should generate a summary pdf including plots (currently non-functional)
#' @return  a print out of the files generated

run_diags <- function(input_dir="./", output_dir=input_dir, save_plots=TRUE, pretty=FALSE){
    #read in filenames
    filenames <- list.files(input_dir)
    filename_hh <- filenames[ grep("household", filenames) ]
    filename_p <- filenames[ grep("people", filenames) ]
    stopifnot(length(filename_hh) * length(filename_p) == 1)
    hh_df <- data.table::fread(paste0(input_dir, filename_hh))
    # write log file
    
    puma_id <- unique(hh_df$puma_id)
    log_filename <- paste0("log_", puma_id, ".txt")
    if(!prettY){
      sink(paste0(output_dir, log_filename))
    }
    print(paste("PUMA ID:", puma_id))
    print("\n")
    print("HOUSEHOLDS")
    print("\n")
    print(paste("Number of households:", nrow(hh_df)))
    print("\n")
    print("Household column names:")
    print(colnames(hh_df))
    print("\n")
    print(paste("Average Longitude:", round(mean(hh_df$long),3)))
    print(paste("Average Latitude:", round(mean(hh_df$lati),3)))
    print("\n")
    print(paste("Number of unique households sampled:", length(unique(hh_df$SERIALNO))))
    print("\n")
    if(!pretty){
      sink()
    }
    
    rm(hh_df)

    #the people information
    p_df <- data.table::fread(paste0(input_dir, filename_p))
  
    if(!pretty){
      sink(paste0(output_dir, log_filename), append=TRUE)
    }
    print("PEOPLE")
    print("\n")
    print(paste("Number of individuals:", nrow(p_df)))
    print("\n")
    print("Column names:")
    print(colnames(p_df))
    mfr<-sum(p_df$SEX == 1)/sum(p_df$SEX == 2)
    print(paste("Male to Female Ratio:", round(mfr, 2)))
    if(!pretty){
    sink()
    }
    return(row)

}
