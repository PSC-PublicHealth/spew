## Functions for working with SPEW directly in the console

#' Format the supplementary data so it is compatible with SPEW
#'
#' @param supplementary_data list of supplementary data
#' @return list of supplementary data that is compatible with SPEW
get_supp_data <- function(supplementary_data){
    supp_data <- list(schools = NULL, workplaces = NULL,
                      marginals = NULL)
    ## Put the data in the proper place
    if(!is.null(supplementary_data)){
        nms <- names(supplementary_data)
        for (ii in 1:length(supplementary_data)) {
            if(nms[ii] %in% names(supp_data)){
                ind <- which(names(supp_data) == nms[i])
                supp_data[[ind]] <- supplementary_data[[ii]]
            }else if (nms[ii] == "moments"){
                supp_data$marginals <- supplementary_data[[ii]]
            }
        }
    }
    return(supp_data)
}

    



#' Summarize a syneco generated by SPEW
#'
#' @param syneco the return object from spewr
#' @param vars_df a dataframe with 3 columns with names "var_name", "pop_type", and "var_type".  var_name should correspond to a variable within the syneco.  pop_type is either "hh" or "p" indicating whether the variable is to be summarized at the household level or person level.  var_type is either "cont" for continuous variable or "cat" for categorical variable.  This changes how the variable is summarized.
#' @param make_plots logical indicating whether we want plots of the individual variables.  Currently is not functional.
#' @param verbose if TRUE then print out summaries.  Default is FALSE
#' @return list of output summaries
#' @export
summarize_syneco <- function(syneco, vars_df,
                             make_plots = FALSE, verbose = FALSE){
    ## Extract the indices with a non-zero number of households and subset
    syneco_inds <- sapply(syneco, function(el) class(el) == "list")
    syneco <- syneco[syneco_inds]
    
    ## make dataframes of households and people
    households <- do.call('rbind', lapply(syneco, "[[", 1))
    people <-  do.call('rbind', lapply(syneco, "[[", 2))
    out <- vector(mode = "list", length = nrow(vars_df))

    ## loop through the rows and summarize the variable
    for(rr in 1:nrow(vars_df)){
        out[[rr]] <- summarize_syneco_var(vars_df[rr,, drop = FALSE],
                                          households, people, make_plots = make_plots,
                                          verbose = verbose)
    }
    names(out) <- vars_df$var_name
    invisible(out)
}


#' Summarize a variable
#' 
#' @param df dataframe with one row with var_name, pop_type, and var_type columns
#' @param households synthetic ecosystem of households (dataframe)
#' @param people synthetic ecosystem of people (data frame)
#' @param make_plots.  Default is FALSE.  If TRUE, summarize through plots
#' @param verbose if TRUE then print out summaries.  Default is FALSE
#' @return summary of the particular variable
summarize_syneco_var <- function(df, households, people,
                                 make_plots = FALSE, verbose = FALSE){
    ## summarize either the household df or  people df
    if( df$pop_type == "hh"){
        sum_df <- households
    } else if (df$pop_type == "p"){
        sum_df <- people
    } else{stop("pop_type must either be 'hh' or 'p'")}
    stopifnot(df$var_name %in% names(sum_df))
    if(df$var_type == "cont"){
        out <- ddply(sum_df, .(place_id), function(sum_df) summary(sum_df[, df$var_name]))
    } else if (df$var_type == "cat"){
        factors <- factor(sum_df[, df$var_name])
        out <- ddply(sum_df, .(place_id), function(sum_df){
            vals <- sum_df[, df$var_name]
            return(table(factor(vals, levels = levels(factors))))
        })
            
    } else{stop("var_type must either be 'cont' or 'cat'" ) }
    if(verbose){
        cat(paste("Variable:", df$var_name, "\n Summary:"))
        print(out, row.names = FALSE)
    }
    return(out)
}
