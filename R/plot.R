#' Plot the synthetic household populations on a map for individual regions
#' @param region_name character name of the region for use in finding with ggmap
#' @param hh_pop the synthetic population generated by spew for a given region
#' @param region_shape shapefile of the region ONLY
#' @param zoom zoom for ggmap 10 is far in, 1 is far out
#' @param title_map - title for the map
#' @return plot of the region, a ggmap object

plot_pop <- function(region_name, hh_pop, region_shape, zoom=8, title_map=region_name){
    #fortify the shape for ggplot
    shape.fort <- fortify(region_shape)
    # get the centers for labeling
    center.df <- as.data.frame(coordinates(region_shape))
    names(center.df) <- c("Longitude", "Latitude")
    center.df$region <- region_name
    print(center.df)
    #get hte map
    google.map <- get_map(c(center.df$Longitude, center.df$Latitude), zoom=zoom, maptype="roadmap")
    stopifnot(sum(c("latitude", "longitude") %in% names(hh_pop)) == 2)
    df.coords <- subset(hh_pop, select=c("latitude","longitude"))
    #making the actual map
    g <- ggmap(google.map) +
    geom_polygon(aes(x = long, y = lat, group = group), data=shape.fort,
               colour = "darkgreen", fill = NA, alpha = .4, size = 2, cex=3) +
    geom_point(aes(x=longitude, y=latitude), data=df.coords, color="blue", size=.5) +
    geom_text(aes(label = region, x = Longitude, y = Latitude), data=center.df, 
            cex=6, font=3) +
    theme_nothing(legend=TRUE) +
    ggtitle(title_map)
    print(g)
    return(g)
}


#' Make maps for each region/puma ID in a directory
#' @param output_dir path to output directory.  The last node in the path will be used as the country name.
#' @param shapefile the corresponding country shapefile
#' @param pretty if TRUE we try to find the place names instead of the numbers.  Currently nonfunctional
#' @param zoom zoom for ggmap 10 is far in, 1 is far out
#' @param parallel logical
#' @return logical
# TODO:  MAKE parallel
make_maps <- function(output_dir=output_dir, shapefile, pretty=FALSE, zoom=7, parallel=FALSE){
    
    country_name <- toupper(basename(output_dir))
    stopifnot("PUMA_ID" %in% colnames(shapefile@data))
    
    if (!parallel) {
        sub_dirs <- list.files(output_dir)
        #loop through each puma_id and make a map
        for(dir_ind in 1:length(sub_dirs)){
            print(sub_dirs[dir_ind])
            
            #TODO:  put below in separate function
            #subset shapefile
            sub_shp <- shapefile[shapefile@data$PUMA_ID== as.numeric(sub_dirs[dir_ind]),]
            
            #get the files to load in
            filenames <- list.files(paste0(output_dir, sub_dirs[dir_ind]))
            household_files <- filenames[ grep("household", filenames) ]
            full_path <- paste0(output_dir, sub_dirs[dir_ind], "/", household_files)
            
            #load in files
            hh_pop<- do.call('rbind', lapply(full_path, read.table, sep=",", skip=1))
            
            #get the header
            header <- readLines(full_path[1], n=1)
            header <- unlist(strsplit(header, split=","))
            header <- gsub("[[:punct:]]", "", header)
            print(header)
            colnames(hh_pop) <- header
            
            #do plotting
            region_name <- toupper(paste(sub_dirs[dir_ind], country_name))
            g <- plot_pop(region_name, hh_pop, sub_shp, zoom=zoom)
            out_nm <- paste0(output_dir, sub_dirs[dir_ind], 
                             "/", sub_dirs[dir_ind], "_", 
                             country_name, ".png")
            
            ggsave(out_nm, g, dpi=50)
        }
    }
    return(TRUE)
}


