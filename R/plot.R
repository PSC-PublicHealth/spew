# Idea: For speed/diagnostics, it could make sense 
# to do another module here which just plots the shapefiles 
# and overlays the points, instead of going through google maps/ggplot2, 
# which takes a long time to run. 

# Idea: We also probably want to make a 'Total' file here, which 
# plots all of the households / people for the entire 
# country of Zambia, as opposed to just the individual PUMA's 

# Idea: It might make more sense to plot the people too, either 
# just the people or in addition. 

#' Plot the synthetic household populations
#' @param region_name character name of the region for use in 
#' finding with ggmap
#' @param hh_pop the synthetic population generated by spew for a 
#' given region
#' @param region_shape shapefile of the region ONLY
#' @param zoom zoom for ggmap 10 is far in, 1 is far out
#' @param title_map - title for the map
#' @return plot of the region, a ggmap object
plot_pop <- function(region_name, hh_pop, region_shape, zoom=8, title_map=region_name){
    # Lee: Do we need both title_map and region_name, if they're the same?  
  
    # fortify the shape for ggplot: What does this do? 
    # Lee: Remember we are using underscores instead of dots in the style guide. 
    # Let's make the comments more descriptive. For example, here I can see 
    # that we are fortifying, but I have no idea what this means. 
    shape.fort <- fortify(region_shape)
    
    # get the centers for labeling. 
    # Lee: Why do we need these? The comments would be more helpful 
    # if they provided the intuition 
    center_df <- as.data.frame(coordinates(region_shape))
    names(center_df) <- c("Longitude", "Latitude")
    center_df$region <- region_name
    print(center_df)
    
    # get hte map. 
    # Lee: What is this doing? Why?
    google.map <- get_map(c(center_df$Longitude, center_df$Latitude), zoom=zoom, maptype="roadmap")
    stopifnot(sum(c("latitude", "longitude") %in% names(hh_pop)) == 2)
    df.coords <- subset(hh_pop, select=c("latitude","longitude"))
    
    # making the actual map.
    # Lee: Let's make sure we are consistent with out function inputs. 
    # About half of these have no spaces, and half have spaces, and some are using a mix. 
    # It doesn't matter, which one we go with, it just matters that it's 
    # consistent throughout the code. 
    g <- ggmap(google.map) +
          geom_polygon(aes(x = long, y = lat, group = group), data = shape.fort,
                     colour = "darkgreen", fill = NA, alpha = .4, size = 2, cex= 3) +
          geom_point(aes(x=longitude, y=latitude), data=df.coords, color="blue", size=.5) +
          geom_text(aes(label = region, x = Longitude, y = Latitude), 
                    data = center_df, cex = 6) +
          theme_nothing(legend=TRUE) +
          ggtitle(title_map)
    print(g)
    return(g)
}

#' Make maps for each region/puma ID in a directory
#' @param output_dir path to output directory.  The last node in 
#' the path will be used as the country name.
#' @param shapefile the corresponding country shapefile
#' @param pretty if TRUE we try to find the place names instead of the numbers.  Currently nonfunctional
#' @param zoom zoom for ggmap 10 is far in, 1 is far out
#' @param parallel logical
#' @return logical
# TODO:  MAKE parallel
make_maps <- function(output_dir=output_dir, shapefile, pretty=FALSE, zoom=7, parallel=FALSE){
    
    country_name <- toupper(basename(output_dir))
    stopifnot("puma_id" %in% colnames(shapefile@data))
    
    # Lee: Remember we are doing if (condition) { }, so lets be sure to include the spaces 
    # here for consistency.  
    if(!parallel){

        sub_dirs <- list.files(output_dir)
        
        # loop through each puma_id and make a map
        for(dir_ind in 1:length(sub_dirs)){
            print(sub_dirs[dir_ind])
            
            #TODO:  put below in separate function
            #subset shapefile 
          
            # Lee:  Subset shapefile TO THIS particular PUMA 
            sub_shp <- shapefile[shapefile@data$puma_id== as.numeric(sub_dirs[dir_ind]),]
            
            #get the files to load in
            filenames <- list.files(paste0(output_dir, sub_dirs[dir_ind]))
            household_files <- filenames[ grep("household", filenames) ]
            full_path <- paste0(output_dir, sub_dirs[dir_ind], "/", household_files)
            
            #load in files
            # Which files? All of the files contained within a PUMA?
            hh_pop<- do.call('rbind', lapply(full_path, read.table, sep=",", skip=1))
            
            #get the header
            # Lee: What is header/why do we need it?
            header <- readLines(full_path[1], n=1)
            header <- unlist(strsplit(header, split=","))
            header <- gsub("[[:punct:]]", "", header)
            print(header)
            colnames(hh_pop) <- header
            
            #do plotting
            region_name <- toupper(paste(sub_dirs[dir_ind], country_name))
            g <- plot_pop(region_name, hh_pop, sub_shp, zoom=zoom)
            out_nm <- paste0(output_dir, sub_dirs[dir_ind], 
                             "/", sub_dirs[dir_ind], "_", 
                             country_name, ".png")
            ggsave(out_nm, g, dpi=50)
        }
    }
    return(TRUE)
}

#' Plot the households
#'
#' @param region_file file name of SPEW household output
#' @param addBoundaries logical indicating whether we should find the corresponding shapefile to add inner region boundaries
#' @param map_title default is NULL is also what we save the file as
#' @param maptype arguments for ggmap default is "roadmap"
#' @param savePlot logical
#' @param hexbin logial - should we use hexagons instead of points?
#' @param nBins how many bins should we use
#' @param alpha transparency as in ggplot
#' @param subSample logical - should we plot the whole thing (possibly very long) or a subset?
#' @return a low res png 
plot_region <- function(region_file, addBoundaries = FALSE, map_title = NULL,  maptype="roadmap", savePlot = TRUE, output_dir = "../diags/", hexBin = FALSE, nBins = 50, alpha = .3, subSample = TRUE, K = 10^4){
    hh_pop <- read.csv(region_file, stringsAsFactors = FALSE)
    hh_pop <- removeExtraHeaders(hh_pop)
    hh_pop$longitude <- as.numeric(hh_pop$longitude)
    hh_pop$latitude <- as.numeric(hh_pop$latitude)
    bbox <- getBBox(hh_pop)
    center_df<- getCenters(hh_pop)

    # Get the google map
    google.map <- get_map(c(center_df$longitude, center_df$latitude), zoom = 5, maptype = maptype)

    # Extract the latitude and longitude coordinates
    stopifnot(sum( colnames(hh_pop) %in%
                   c("latitude", "longitude")) >= 2)
    df_coords <- subset(hh_pop, select=c("latitude","longitude", "place_id"))
    df_coords <- na.omit(df_coords)

    if (is.null(map_title)){
        map_title <- toupper(hh_pop$place_id)[1]
    }

    
    if(hexBin){
         gp <- ggmap(google.map) 
         bins <- nBins
         g <- gp +  stat_bin2d(bins=bins, data = df_coords,
                                           aes(x = longitude, y = latitude, fill = factor(place_id)
                               ),
                                           alpha = alpha, 
                               inherit.aes = FALSE) +
             coord_equal(ratio = 1/1)+
           #  scale_fill_gradient(low = "blue", high = "goldenrod") +
             ggtitle(map_title) +
             scale_y_continuous(limits =  c(bbox$lat_min, bbox$lat_max), expand = c(0,0)) +
             scale_x_continuous(limits = c(bbox$long_min, bbox$long_max), expand = c(0,0)) +
             coord_map() + theme_nothing(legend = FALSE)
  
    } else {
        if (subSample){
            # take a sample of min(#Points, 10^5) points to plot
            if (nrow(df_coords) > K){
                inds <- sample(1:nrow(df_coords), K)
                df_coords <- df_coords[inds,]
            }
        }
        
    # making the actual map.
        g <- ggmap(google.map) + 
            geom_point(aes(x = longitude, y = latitude, col=factor(place_id)),
                       data=df_coords, size = .5) +
            theme_nothing(legend=FALSE) +
            ggtitle(map_title) +
            scale_y_continuous(limits =  c(bbox$lat_min, bbox$lat_max), expand = c(0,0)) +
            scale_x_continuous(limits = c(bbox$long_min, bbox$long_max), expand = c(0,0))
    }
    g <- g + geom_text(aes(x = longitude, y = latitude), label = map_title,
                      data = center_df, cex = 6)
    g
    
    if (addBoundaries){
        # TODO
        # get the shapefile
        # format the shapefile
        # add the boundary lines to the plot
    }

    # If ../diags does not exist, make the folder
    output_dir <- file.path(dirname(region_file), "../diags/")
    if( !file.exists(output_dir)){
        dir.create(output_dir)
    }

    # Save the plot as a low res png
    filename <- paste0(output_dir, map_title, ".png")
    print(filename)
    if (savePlot){
        ggsave(filename, g, dpi=50)
    } else {
        print(g)
    }
    
}

#' Remove Extra Headers
#'
#' @param hh_pop a household population output from SPEW
#' @return hh_pop minus extra headers
removeExtraHeaders <- function(hh_pop){
    header_inds <- which(hh_pop$place_id == "place_id")
    if (length(header_inds) > 0 ){
        hh_pop <- hh_pop[-header_inds,]
    }
    return(hh_pop)
}

#' Get the bounding box of a pop
#'
#' @param hh_pop SPEW household population output has longitude and lat parameters
#' @return list with long_min, long_max, lat_min, lat_max
getBBox <- function(hh_pop){
    hh_pop$longitude <- as.numeric(hh_pop$longitude)
    hh_pop$latitude <- as.numeric(hh_pop$latitude)
    long_min <- floor(min(hh_pop$longitude, na.rm = TRUE))
    long_max <- ceiling(max(hh_pop$longitude, na.rm = TRUE))
    lat_min <- floor(min(hh_pop$latitude, na.rm = TRUE))
    lat_max <- ceiling(max(hh_pop$latitude, na.rm= TRUE))
    bbox <- list(long_min = long_min, long_max = long_max,
                 lat_min = lat_min, lat_max = lat_max)
    return(bbox)
}

#' Get the geographic center of a population
#'
#' @param hh_pop SPEW output for household population
#' @return data frame with region name, long and lat
getCenters <- function(hh_pop){
    region_name <- toupper(hh_pop$place_id[1])
    longitude <- mean(hh_pop$longitude, na.rm = TRUE)
    latitude <- mean(hh_pop$latitude, na.rm = TRUE)
    center_df <- data.frame(region_name = region_name,
                            longitude = longitude,
                            latitude = latitude)
    return(center_df)
}


## # testing
## library(ggmap)
## setwd("~/Desktop/uruguay/eco")
## region_file <- "output_858019_household.csv"
## plot_region(region_file, savePlot = FALSE, hexBin = FALSE, nBins = 50, alpha=.8, subSample = TRUE)

## files <- list.files()
## hh_files <- files[grepl("household", files)]

## # loop through
## for (hh_file in hh_files){
##     plot_region(hh_file)
## }


## setwd("~/Desktop/eco")

## region_file <- list.files()[1]

## t <- proc.time()[3]
## nBins <- 30
## alpha <- .5
## K <- 10^5
## plot_region(region_file[1], savePlot = TRUE, hexBin = FALSE, nBins = nBins, alpha = alpha, subSample = TRUE, K = K)
## print(proc.time()[3] - t)
